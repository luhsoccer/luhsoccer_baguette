# Render View
The render view component draws the markers to an image which is than displayed with ImGui in the window.

## Model
The model class is capable of loading the vertices, vertex colors and texture coordinates from a given 3d model (.obj file). For loading it makes use of the library tinyObjLoader (https://github.com/tinyobjloader/tinyobjloader). The vertex data is grouped in the Vertex struct and they are indexed. The model also saves a reference to the shader program to be used to render later.

## Mesh
A Mesh finally is the type of object which can be a loaded 3d model, or just a simple model defined by bunch of vertices and vertex colors (mainly the 2d markers). It offers several create methods to be created from a given model or from vertex data directly. It than creates with the wrapper classes from [New Rendering](../new_rendering/README.md) the needed buffers (VAO's, textures, ...) and buffers the given data on the gpu. It also contains the render method which in detail binds the texture (if any given) or else sets the vertex colors and a bunch of matrices needed in the vertex shader to apply the translation, rotation and scale to the model. Finally it draws the mesh or the vertex arrays respectively.
There is also the posibility to set the vertices of an existing mesh. This is needed for 2d markers like linestrip, which size could change over time while already beeing displayed.

## The RenderView itself
The Renderview itself is finally doing all the hard stuff. It creates a list of possible drawn models at the program start and compiles the shaders. It also setsup the MSAA offscreen rendering which in detail renders 4 samples offscreen to later render a sharp texture to the screen in the ImGui window. Mainly the RenderView has an update and an render method. In the update method the meshes are created from the luhviz markers if they dont existed before. If they did, the changed properties are applied to the existing meshes. This Process is done seperately for 3DMarkers and 2DMarkers because their data is different.
The render method is very straight forward. First it sets up the offscreen rendering framebuffer and loads the shader program. After that the opaque meshes are drawn first. After that the transparent meshes are drawn ordered by their distance to the camera (from far to near). That is necessary to transparent objects beeing drawn realisticly. The last step involves rendering the text meshes to the screen. The resulting image is than finally displayed through an ImGui::Image component. In the UpdateMouseControl function the [Common Controls](../common/README.md) is used to update the camera translation and roation. Also the different manipulation modes like teleport, execute skill... are behandelt here.
